# 生命周期<sup>生命周期的主要目标是避免悬垂引用（dangling references）</sup>
Rust 中的每一个引用都有其生命周期（lifetime），也就是引用保持有效的作用域。大部分时候生命周期是隐含并可以推断的，正如大部分时候类型也是可以推断的一样。类似于当因为有多种可能类型的时候必须注明类型，也会出现引用的生命周期以一些不同方式相关联的情况，所以 Rust 需要我们使用泛型生命周期参数来注明它们的关系，这样就能确保运行时实际使用的引用绝对是有效的。


生命周期是另一类我们已经使用过的泛型<sup>怎么理解? 生命周期是泛型？</sup>。不同于确保类型有期望的行为，生命周期用于保证引用在我们需要的整个期间内都是有效的。

```txt
   生命周期是另一类我们已经使用过的泛型<sup>怎么理解? 生命周期是泛型？</sup>

  类型泛型（Type Generics）VS 生命周期泛型（Lifetime Generics）
  
  A. 类型泛型 <T>：抽象的是“类型”
     当你写 Vec<T> 时，你是在告诉编译器：“我不在乎具体的类型是什么，它可以是 i32，也可以是 String，只要在使用时确定即可。”
    功能： 确保代码对不同类型的兼容性
  
  B. 生命周期泛型 <'a>：抽象的是“作用域/持续时间”
     当你写 &'a str 时，你是在告诉编译器：“我不在乎这个引用具体活多久（是在 main 函数结束，还是在某个循环结束），我只要求它至少能活到 'a 这么久。”
     功能： 确保引用在使用的整个过程中都是**有效（Valid）**的，防止悬垂指针。

 为什么 Rust 要把生命周期设计成泛型？
  因为引用的有效性是代码逻辑的一部分。正如你不能把 String 传给期待 u32 的函数一样，你也不能把一个“短命”的引用传给一个期待“长命”引用的函数。

  将生命周期作为泛型处理，使得编译器可以利用同一套语法框架（即尖括号 < >）来同时处理数据的类型安全和内存安全。
```

Rust 中的每一个引用都有其生命周期（lifetime），也就是引用保持有效的作用域

---

## Rust编译器中的概念
### 借用检查器（borrow checker）
Rust **编译器**<sup>编译器中的，因此不会对性能产生影响</sup>有一个借用检查器（borrow checker），它比较作用域来确保所有的借用都是有效的。

---

## 生命周期注解 <sup>描述生命周期的关系<sup>
生命周期注解**并不改变任何引用的生命周期的长短**。相反它们描述了多个引用生命周期相互的关系，而不影响其生命周期。

生命周期注解有着一个不太常见的语法：生命周期参数名称必须以撇号（'）开头，其名称通常全是小写，类似于泛型其名称非常短。大多数人使用 'a 作为第一个生命周期注解。生命周期参数注解位于引用的 & 之后，并有一个空格来将引用类型与生命周期注解分隔开。
```rust
   &i32        // 引用
   &'a i32     // 带有显式生命周期的引用
   &'a mut i32 // 带有显式生命周期的可变引用
```
单个的生命周期注解本身没有多少意义，因为生命周期注解告诉 Rust 多个引用的泛型生命周期参数如何相互联系的。

### 函数签名中的生命周期注解
为了在函数签名中使用生命周期注解，需要在函数名和参数列表间的尖括号中声明泛型生命周期（lifetime）参数，就像泛型类型（type）参数一样。

希望函数签名表达如下限制：也就是这两个参数和返回的引用存活的一样久。（两个）参数和返回的引用的生命周期是相关的: 
```rust
 // 将生命周期作为泛型处理，使得编译器可以利用同一套语法框架（即尖括号 < >）来同时处理数据的类型安全和内存安全。
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}
```

通过在函数签名中指定生命周期参数时，我们并没有改变任何传入值或返回值的生命周期，而是指出任何不满足这个约束条件的值都将被借用检查器拒绝。

---

## 函数签名中的生命周期注解
为了在函数签名中使用生命周期注解，需要在函数名和参数列表间的尖括号中声明泛型生命周期（lifetime）参数，就像泛型类型（type）参数一样。
```rust
// 函数签名表达如下限制：也就是这两个参数和返回的引用存活的一样久
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}
```

记住通过在函数签名中指定生命周期参数时，我们并没有改变任何传入值或返回值的生命周期，而是指出任何不满足这个约束条件的值都将被借用检查器拒绝。注意 longest 函数并不需要知道 x 和 y 具体会存在多久，而只需要知道有某个可以被 'a 替代的作用域将会满足这个签名。

当在函数中使用生命周期注解时，这些注解出现在函数签名中，而不存在于函数体中的任何代码中<sup>**编译器的工作，所以不会对性能产生影响**</sup>。生命周期注解成为了函数约定的一部分，非常像签名中的类型。让函数签名包含生命周期约定意味着 Rust 编译器的工作变得更简单了。如果函数注解有误或者调用方法不对，编译器错误可以更准确地指出代码和限制的部分。如果不这么做的话，Rust 编译会对我们期望的生命周期关系做更多的推断，这样编译器可能只能指出离出问题地方很多步之外的代码

当具体的引用被传递给 longest 时，被 'a 所替代的具体生命周期是 x 的作用域与 y 的作用域相重叠的那一部分。换一种说法就是泛型生命周期 'a 的具体生命周期等同于 x 和 y 的生命周期中较小的那一个。

### 结构体定义中的生命周期注解
```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().unwrap();
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
```

### 方法定义中的生命周期注解
```rust
impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}
```

---

## 生命周期省略（Lifetime Elision）
现在我们已经知道了每一个引用都有一个生命周期，而且我们需要为那些使用了引用的函数或结构体指定生命周期。

```rust
// 为什么这段代码可以编译? 因为生命周期注解被省略了
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}

---> 签名等价于: fn first_word<'a>(s: &'a str) -> &'a str {


```

### 生命周期省略规则（lifetime elision rules）
|名词|解释|备注|
|-|-|-|
|- 输入生命周期（input lifetimes）|- 函数或方法的参数的生命周期|-|
|-|-|-|
|- 输出生命周期（output lifetimes）|- 返回值的生命周期|-|
|-|-|-|

##### 生命周期省略规则（lifetime elision rules）
|规则|解释|备注|
|-|-|-|
|- 规则1|- 第一条规则是编译器为每一个引用参数都分配一个生命周期参数|- 函数有一个引用参数的就有一个生命周期参数：fn foo<'a>(x: &'a i32)，有两个引用参数的函数就有两个不同的生命周期参数，fn foo<'a, 'b>(x: &'a i32, y: &'b i32)，依此类推。|
|-|-|-|
|-规则2|- 第二条规则是如果只有一个输入生命周期参数，那么将它赋予给所有输出生命周期参数：fn foo<'a>(x: &'a i32) -> &'a i32|-|
|-|-|-|
|-规则3|- 第三条规则是如果方法有多个输入生命周期参数并且其中一个参数是 &self 或 &mut self，说明这是个方法，那么所有输出生命周期参数被赋予 self 的生命周期|-|

---

## 静态生命周期: 'static
静态生命周期: 'static，其生命周期能够存活于整个程序期间。
```rust
let s: &'static str = "I have a static lifetime.";
```

## 结合泛型类型参数、trait bounds 和生命周期
在同一函数中指定泛型类型参数、trait bounds 和生命周期的语法！:
```rust
use std::fmt::Display;

fn longest_with_an_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
    T: Display,
{
    println!("Announcement! {ann}");
    if x.len() > y.len() { x } else { y }
}

```