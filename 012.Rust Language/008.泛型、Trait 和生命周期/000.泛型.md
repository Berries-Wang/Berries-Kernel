# 泛型



## 泛型代码的性能——泛型代码的单态化（monomorphization）
泛型并不会使程序比具体类型运行得慢

Rust 通过在编译时进行泛型代码的单态化（monomorphization）来保证效率。单态化是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程

```rust
let integer = Some(5);
let float = Some(5.0);
```

当 Rust 编译这些代码的时候，它会进行单态化。编译器会读取传递给 Option<T> 的值并发现有两种 Option<T>：一个对应 i32 另一个对应 f64。为此，它会将泛型定义 Option<T> 展开为两个针对 i32 和 f64 的定义，接着将泛型定义替换为这两个具体的定义。

编译器生成的单态化版本的代码看起来像这样（编译器会使用不同于如下假想的名字）：
```rust
enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
```

泛型 Option\<T\> 被编译器替换为了具体的定义。因为 Rust 会将每种情况下的泛型代码编译为具体类型，使用泛型没有运行时开销。当代码运行时，它的执行效率就跟好像手写每个具体定义的重复代码一样。这个单态化过程正是 Rust 泛型在运行时极其高效的原因

### 单态化证据
```rust
#[inline(never)] // 防止编译器把函数优化掉，方便观察
pub fn add<T: std::ops::Add<Output = T>>(a: T, b: T) -> T {
    a + b
}

fn main() {
    let _ = add(1i32, 2i32);
    let _ = add(1.0f64, 2.0f64);
}

// wei@Berries:~/OPEN_SOURCE/rust-stu/module_rust$ cargo rustc -- --emit llvm-ir  // 生成 LLVM IR 代码
// ---> 生成的 LLVM IR 代码中，add 函数被单态化为 add_i32 和 add_f64 两个函数，分别处理 i32 和 f64 类型的加法操作:  target/debug/deps/*.ll

- define internal double @_ZN11module_rust3add17h32476588be1869f8E(double %a, double %b) unnamed_addr #0 !dbg !33 { ... }
- define internal i32 @_ZN11module_rust3add17hc6fee0b00abfd408E(i32 %a, i32 %b) unnamed_addr #0 !dbg !48 { ...}

 ; module_rust::main
; Function Attrs: nonlazybind uwtable
define hidden void @_ZN11module_rust4main17h2e1abf750b099551E() unnamed_addr #1 !dbg !61 {
start:
; call module_rust::add  // 在 LLVM IR 中，分号 ; 开头的行全都是注释。
  %_1 = call i32 @_ZN11module_rust3add17hc6fee0b00abfd408E(i32 1, i32 2), !dbg !62
; call module_rust::add
  %_2 = call double @_ZN11module_rust3add17h32476588be1869f8E(double 1.000000e+00, double 2.000000e+00), !dbg !63
  ret void, !dbg !64
}
```