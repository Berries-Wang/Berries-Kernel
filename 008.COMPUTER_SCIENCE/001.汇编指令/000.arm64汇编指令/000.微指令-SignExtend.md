# 微指令 SignExtend
> 阅读:[ADRP](https://developer.arm.com/documentation/ddi0602/2025-09/Base-Instructions/ADRP--Form-PC-relative-address-to-4KB-page-) 或 [ADRP:pdf](../../../007.BOOKs/Arm®%20Architecture%20Reference%20Manual%20for%20A-profile%20architecture/ARMV8-ADDI0487L_b_a-profile_architecture_reference_manual-1-5000.pdf)

## 如何理解下面的操作?
```txt
constant integer d = UInt(Rd);
constant bits(64) imm = SignExtend(immhi:immlo:Zeros(12), 64);
```

这个就得查询手册了，这里只简单介绍一下分析过程中所涉及的几个微指令的功能：
```txt
   SignExtend ： 有符号地展开(展开为指定位数)立即数，这个有符号，是因为里面的操作就是取的就是立即数的最高位（符号位）来进行展开的

    // SignExtend()
    // ============
    
    bits(N) SignExtend(bits(M) x, integer N)
        assert N >= M;
        return Replicate(x<M-1>, N-M) : x;

    // x<M-1> ,就是取立即数x的M-1位（x为M位的立即数） ， 那么这句话的含义就是取x的最高位，即符号位
    // 'Replicate(x<M-1>, N-M) : x' 中的 ‘:’(冒号) 就是拼接的意思，即 "01:00" 执行之后就是 "0100"
    
    ------------------
    
    // Replicate()
    // ===========
    
    bits(M*N) Replicate(bits(M) x, integer N);
    // Replicate(bits(M) x, integer N) 的含义就是 将立即数x复制N遍，并拼接在一起 

    bits(N) Zeros(integer N)
       return Replicate('0',N);

    constant bits(64) base = PC64<63:12>:Zeros(12);
    X[d, 64] = base + imm;
    // 64位常量base = 64位PC寄存器的第[63,12]位再拼接12个0 即： base = (PC64 & ~0xFFF)
    // 0xFFF == 0b0000 1111 1111 1111
```