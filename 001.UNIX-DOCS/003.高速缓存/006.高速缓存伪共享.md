# 高速缓存伪共享
学习:[奔跑吧Linux内核（第2版）卷1：基础架构#1.1.12　高速缓存伪共享](../../006.BOOKs/UNIX%20Network%20Programming%20Volume%201:%20Socket%20Networking%20API%20(3rd%20Edition).epub)   &   [《RISC-V体系结构编程与实践（第2版）》<sup>笨叔·著</sup>#12.5 高速缓存伪共享](../006.BOOKs/RISC-V%20Architecture%20Programming%20and%20Practice.pdf)

## 背景
高速缓存是以高速缓存行为单位来从内存中读取数据并且缓存数据的 <sub>[奔跑吧Linux内核（第2版）卷1：基础架构#1.1.12　高速缓存伪共享](../../006.BOOKs/UNIX%20Network%20Programming%20Volume%201:%20Socket%20Networking%20API%20(3rd%20Edition).epub)</sub>

## 产生原因
两个或多个变量都缓存到了同一个高速缓存行中，CPU之间（多线程）在不断地争夺对高速缓存行的控制权，不断使对方的高速缓存行失效，不断地把数据写回内存，导致系统性能下降。


## 解决方式
### 材料解析
```c
   typedef struct counter_s
   {
       uint64_t packets;
       uint64_t bytes;
       uint64_t failed_packets;
       uint64_t failed_bytes;
       uint64_t pad[4]; // 填充，使得一个counter_s变量独占一个缓存行
   }counter_t __attribute__(__aligned__((64)));
   // __attribute__(__aligned__((64))  是 GNU C 编译器（GCC）的一个扩展属性，用于指定变量或结构体的内存对齐方式。64单位是字节

   // 即，这个结构体定义只是 使得一个counter_s变量独占一个缓存行 ，如果要完全解决高速缓存伪共享，则：
   // 1. 每个关键成员独立缓存行: 高速缓存行对齐（align）技术
     typedef struct counter_s
     {
         uint64_t packets        __attribute__((aligned(64)));
         uint64_t bytes          __attribute__((aligned(64)));
         uint64_t failed_packets __attribute__((aligned(64)));
         uint64_t failed_bytes   __attribute__((aligned(64)));
     } counter_t;
     
     // 2. 采用高速缓存行填充（padding）
     typedef struct counter_s
     {
         uint64_t packets;
         uint64_t pad1[7];  // 填充56字节，使packets独占缓存行
         
         uint64_t bytes;
         uint64_t pad2[7];
         
         uint64_t failed_packets;
         uint64_t pad3[7];
         
         uint64_t failed_bytes;
         uint64_t pad4[7];
     } counter_t;
```
·