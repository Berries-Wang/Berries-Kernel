# 页面分配

## 分配物理页面
```c 
    // 000.LINUX-5.9/include/linux/gfp.h
    #define alloc_page(gfp_mask) alloc_pages(gfp_mask, 0) // 伙伴系统的核心函数

    // 伙伴系统核心数据结构
    struct zone {
      // *****
      	/**
         * free_area[0]： 由2^0个4K页组成的链表
         * 
	       *  free areas of different sizes 
	       * 
	       * [Run Linux Kernel (2nd Edition) Volume 1: Infrastructure.epub]#图3.12　伙伴系统的空闲页块的管理
	       * 
	       * 看示意图就可以明白
	       * 伙伴系统的核心数据结构，管理空闲页块（page block）链表的数组
         * 
         * 应用:
         * 1. [华为云欧拉操作系统 (HCE) 用户指南 (for 华为云Stack 8.5.0) 01.pdf](001.UNIX-DOCS/000.内存管理/998.REFS/华为云欧拉操作系统 (HCE) 用户指南 (for 华为云Stack 8.5.0) 01.pdf)
	      */
	      struct free_area	free_area[MAX_ORDER];
        
        // ....
  } ____cacheline_internodealigned_in_smp;


    // <mm/page_alloc.c>
    // __get_free_pages()函数返回的是所分配内存的内核空间虚拟地址。如果所分配内存是线性映射的物理内存，则直接返回线性映射区域的内核空间虚拟地址
    unsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order)
```

## 释放物理页面
```c
  
  void __free_pages(struct page *page, unsigned int order);
  #define __free_page(page) __free_pages((page), 0)
  #define free_page(addr) free_pages((addr), 0)

```

## 核心函数
- get_page_from_freelist #'000.LINUX-5.9/mm/page_alloc.c'

外碎片化（external fragmentation）是指系统有足够的空闲内存，但是没办法分配出想要的内存块。这是因为有很多空闲内存分散在众多的页块中，导致没法分配出一个完整和连续的大内存块。那如何检查外碎片化呢？Linux内核在分配物理页面时，若发现没有办法分配出想要的物理内存，特别是大内存块，那么它会去从其他迁移类型中挪用内存（__rmqueue_fallback()函数），于是我们就认为有发生外碎片化的倾向。

这个临时增加水位的优化方法是，当检查到有外碎片化倾向时，就临时提高低水位，这样可以提前触发kswapd内核线程回收内存，然后触发kcompactd内核线程做内存规整，这样有助于快速满足分配大内存块的需求