# 内存屏障
## 内存屏障 & 指令原语
> [Run Linux Kernel (2nd Edition) Volume 1: Infrastructure.epub]#2.5　内存屏障

### 指令原语
- 获取（acquire）屏障原语：该屏障原语之后的读写操作不能重排到该屏障原语前面，通常该屏障原语和加载指令结合。
- 释放（release）屏障原语：该屏障原语之前的读写操作不能重排到该屏障原语后面，通常该屏障原语和存储指令结合。
- 加载-获取（load-acquire）屏障原语：含有获取屏障原语的读操作，相当于单方向向后的屏障指令。所有加载-获取内存屏障指令后面的内存访问指令只能在加载-获取内存屏障指令执行后才能开始执行，并且被其他CPU观察到。普通的读和写操作可以向后越过该屏障指令，但是之后的读和写操作不能向前越过该屏障指令。
- 存储-释放（store-release）屏障原语：含有释放屏障原语的写操作，相当于单方向向前的屏障指令。只有所有存储-释放屏障原语之前的指令完成了，才能执行存储-释放屏障原语之后的指令，这样其他CPU可以观察到存储-释放屏障原语之前的指令已经执行完。普通的读和写可以向前越过存储-释放屏障指令，但是之前的读和写操作不能向后越过存储-释放屏障指令。


## 内存屏障产生原因

若`程序在执行时的内存访问顺序`和`程序代码编写的访问顺序`不一致，会导致内存乱序访问。内存乱序访问的出现是为了提高程序执行的效率。内存乱序访问主要发生在如下两个阶段:
1. 编译时，编译器优化导致内存乱序访问
2. 执行时，多个CPU间交互引起的内存乱序访问。

编译器会把符合人类思维的代码（C语言代码）翻译成符合CPU运算规则的汇编指令，编译器了解底层CPU的思维逻辑，因此他会在翻译汇编指令时对其进行优化。如内存访问指令的重新排序可以提高指令级并行效率。然后，这些优化会与程序员原始代码逻辑不符，导致一些错误发生。编译时的乱序访问可以通过barrier()函数来规避:
```c
    #define barrier() __asm__ __volatile__("": : :"memory") 

    // 这行代码语法上的功能?
    /**
     *  "memory" 是内联汇编中的 内存破坏子（memory clobber），它告诉`编译器`：
     *     这段汇编代码会读取或修改内存中的任意位置，编译器不能对内存访问顺序进行优化或假设。
     *      ---> "memory" 是 编译器级别 的屏障，而 ARM64 的 DMB（数据内存屏障）是 CPU 级别 的屏障
     */
```

barrier() 函数告诉编译器，不要为了性能优化而将这些代码重排。

由于现代处理器普遍采用超标量架构、乱序发射以及乱序执行等技术来提高指令级并行效率，因此指令的执行序列在处理器流水线中可能被打乱，与程序代码编写时序列不一致。


## 内存访问一致性模型——弱一致性（weak consistency）内存模型
内存访问一致性模型: 在一个系统中含有n个处理器P1～Pn，假设每个处理器包含Si个存储器操作，那么从全局来看，可能的存储器访问序列有多种组合。为了保证内存访问的一致性，需要按照某种规则来选出合适的组合，这个规则叫作内存一致性模型（memory consistency model）

**原子一致性（atomic consistency）内存模型**<sup>使用一个全局时间比例（global time scale）部件来决定存储器访问时序，从而判断最近访问的数据: 实现全局时间比例部件的代价比较大</sup>  

---> 

**顺序一致性（sequential consistency）内存模型**<sup>采用每一个处理器的局部时间比例（local time scale）部件来确定最新数据</sup>

--->

**处理器一致性（processor consistency）内存模型**<sup>顺序一致性内存模型的进一步弱化，仅要求来自同一个处理器的写操作具有一致性的访问即可</sup>

*以上这些内存一致性模型是针对存储器的读写指令展开的*

### 弱一致性（weak consistency）内存模型
使用内存同步指令（也称为内存屏障指令）。在这种模型下，存储器访问指令被分成数据指令和同步指令两大类

在一个多处理器系统中，满足如下3个条件的内存访问称为弱一致性的内存访问：
- 所有处理器对全局同步变量的访问是顺序一致的。
- 在之前的全局数据（global data）访问完成之前，任何处理器不能访问全局同步变量。
- 在全局同步变量释放之前，任何处理器不能访问全局数据。


弱一致性内存模型要求同步访问（访问全局同步变量）是顺序一致的，在一个同步访问可以执行之前，之前的所有数据访问必须完成。在一个正常的数据访问可以执行之前，所有之前的同步访问必须完成。

在ARM处理器中使用`内存屏障指令`<sup>保证 程序执行顺序 和 代码编写顺序 保持一致</sup>的方式来实现同步访问。内存屏障指令的基本原则如下：
1. 所有在内存屏障指令之前的数据访问必须在内存屏障指令之前完成。
2. 所有在内存屏障指令后面的数据访问必须等待内存屏障指令执行完。
3. 多条内存屏障指令是按顺序执行的。

处理器会根据内存屏障的作用范围进行细分，例如，ARM64处理器把内存屏障指令细分为数据存储屏障指令、数据同步屏障指令以及指令同步屏障指令


## 参考
1. 1.请阅读:  [奔跑吧Linux内核（第2版）卷1：基础架构#1.1.4　内存屏障产生的原因](../006.BOOKs/Run%20Linux%20Kernel%20(2nd%20Edition)%20Volume%201:%20Infrastructure.epub)#1.1.4　内存屏障产生的原因


