# 中断与异常
学习: [奔跑吧Linux内核（第2版）卷1：基础架构#1.7　ARM64异常处理](../../007.BOOKs/Run%20Linux%20Kernel%20(2nd%20Edition)%20Volume%201:%20Infrastructure.epub)  & [learn_the_architecture_-_aarch64_exception_model_102412_0103_02_en.pdf](../../006.REFS/learn_the_architecture_-_aarch64_exception_model_102412_0103_02_en.pdf) & [Learn the architecture - Generic Interrupt Controller v3 and v4](././../../006.REFS/learn_the_architecture_-_generic_interrupt_controller_v3_and_v4__overview_198123_0302_03_en.pdf)

## 异常/中断是什么
An interrupt is a signal to the processor that an event has occurred which needs to be dealt with. Interrupts are typically generated by peripherals.<sup>From: [Learn the architecture - Generic Interrupt Controller v3 and v4#1. Overview](././../../006.REFS/learn_the_architecture_-_generic_interrupt_controller_v3_and_v4__overview_198123_0302_03_en.pdf)</sup> <sup> ，中断与异常的处理使用同一套机制，差异仅在选择handler中提现： [04-硬件环境与软件抽象：特权级模型与中断 [中山大学 操作系统原理]](../../001.UNIX-DOCS/000.内存管理/998.REFS/000.中山大学-操作系统/2-0306-hardware-interrupt.pdf)</sup>
- ![wechat_2026-01-25_204120_905.png](./999.IMGS/wechat_2026-01-25_204120_905.png)
- ![wechat_2026-01-25_204655_983.png](./999.IMGS/wechat_2026-01-25_204655_983.png)

## AArch64状态的异常等级
![20251023114446.jpg](../999.IMGS/20251023114446.jpg)

## 异常分类
- 中断
- 中止
- 复位
- 软件产生的异常

##### 中断
在ARM处理器中，中断请求分成中断请求（Interrupt Request，IRQ）和快速中断请求（Fast Interrupt Request，FIQ）两种，其中FIQ的优先级要高于IRQ。在芯片内部，分别有连接到处理器内部的IRQ和FIQ两根中断线。通常系统级芯片内部会有一个中断控制器，众多的外部设备的中断引脚会连接到中断控制器，由中断控制器来负责中断优先级调度，然后发送中断信号给ARM处理器，中断模型如图1.32所示

[006.BOOKs/Run Linux Kernel (2nd Edition) Volume 1: Infrastructure.epub#1.7.1　异常类型]
- ![wechat_2025-10-24_221405_928.png](../999.IMGS/wechat_2025-10-24_221405_928.png)

##### 中止
中止主要有指令中止（instruction abort）和数据中止（data abort）两种，它们通常是指访问外部存储单元时候发生了错误，处理器内部的MMU捕获这些错误并且报告给处理器。

指令中止是指当处理器尝试执行某条指令时发生的错误。而数据中止是指使用加载或者存储指令读写外部存储单元时发生的错误。

##### 复位
复位（reset）操作是优先级最高的一种异常处理。复位操作通常用于让CPU复位引脚产生复位信号，让CPU进入复位状态，并重新启动。

##### 软件产生的异常
ARMv8架构中提供了3种软件产生的异常。这些异常通常是指软件想尝试进入更高的异常等级而造成的错误。
- SVC指令：允许用户模式的程序请求操作系统服务。
- HVC指令：允许客机（guest OS）请求主机服务。
- SMC指令：允许普通世界（normal world）中的程序请求安全监控服务。


---
## GIC（Generic Interrupt Controller）
> GIC 就是中断模型中的‘中断控制器’ , 和 STM32 中的NVIC似乎类似<sub>在功能上类似，即都是ARM体系结构下的中断控制器，负责管理和处理中断，以提升CPU的效率。但GIC是NVIC的“超级加强版”，增加了对多核、大量中断源、虚拟化等高级功能的支持</sub>

### GIC 功能简介 <sup>详细需仔细阅读:[Learn the architecture - Generic Interrupt Controller v3 and v4](././../../006.REFS/learn_the_architecture_-_generic_interrupt_controller_v3_and_v4__overview_198123_0302_03_en.pdf) & [Arm CoreLink GIC-700 Generic Interrupt Controller Technical Reference Manual](../../007.BOOKs/corelink_gic_700_generic_interrupt_controller_trm_101516_0400_12_en.pdf) </sup>
Small systems might have only a few interrupt sources and a single processor. However, larger systems might have many more potential interrupt sources and processors. The GIC performs the critical tasks of interrupt management, prioritization, and routing. The GIC marshals all interrupts from across the system, prioritizes them, and sends them to a core to be dealt with. GICs are primarily used to boost processor efficiency and to enable interrupt virtualization<sup>From: [Learn the architecture - Generic Interrupt Controller v3 and v4#1. Overview](././../../006.REFS/learn_the_architecture_-_generic_interrupt_controller_v3_and_v4__overview_198123_0302_03_en.pdf)</sup> (小型系统可能只有少数中断源和单个处理器。然而，大型系统的潜在中断源和处理器数量可能远超于此。通用中断控制器（GIC）承担着中断管理、优先级排序和路由分配等关键任务。它能统合整个系统的中断信号，进行优先级排序后将其发送至相应核心进行处理。GIC的主要作用在于提升处理器效率并实现中断虚拟化功能。)

A Generic Interrupt Controller (GIC) takes interrupts from peripherals, prioritizes them, and delivers them to the appropriate processor core. <sup>From: [Learn the architecture - Generic Interrupt Controller v3 and v4#3. What is a Generic Interrupt Controller?](././../../006.REFS/learn_the_architecture_-_generic_interrupt_controller_v3_and_v4__overview_198123_0302_03_en.pdf)</sup>(通用中断控制器（GIC）负责接收来自外设的中断信号，对其进行优先级排序，并将其传递给相应的处理器核心进行处理。)

![Figure 3-1: GIC example](../999.IMGS/Screenshot%20from%202025-10-25%2009-24-05.png)

## How interrupts are signaled to the interrupt controller (中断如何传输到中断控制器上)
参考: [Learn the architecture - Generic Interrupt Controller v3 and v4#How interrupts are signaled to the interrupt controller](././../../006.REFS/learn_the_architecture_-_generic_interrupt_controller_v3_and_v4__overview_198123_0302_03_en.pdf)

### 两种传输方式
- Dedicated interrupt signal
- Message signaled interrupt signal <sub>对大型系统设计有显著优势</sub>

> 如何路由的，详细参考文档，或需要时再研究透彻，目前目标研究内核，GIC知道大概就行了


### Running priority and preemption（优先级被切分为priority group & subpriority, 关于抢占，对比STM32 NVIC学习）
> 总结就是: priorityGroup 决定是否能被抢占，subPriority来决定处理的顺序(正在执行的中断(A)不会被后续产生的同等priorityGroup的中断(B)所抢占，即使B的subPriority的优先级更高) 

The Binary Point registers split the priority into two fields, group priority and sub-priority, as you can see here: <sup>From: [Learn the architecture - Generic Interrupt Controller v3 and v4#Running priority and preemption](../../006.REFS/learn_the_architecture_-_generic_interrupt_controller_v3_and_v4__overview_198123_0302_03_en.pdf)</sup>

![wechat_2025-10-27_072045_500.png](../999.IMGS/wechat_2025-10-27_072045_500.png)


## Interrupt state machine (中断信号状态变化)
包含异常处理流程的注意事项:1)怎么才是表示本次异常处理结束;

### Level sensitive interrupts(电平敏感中断) VS Edge-triggered interrupts(边沿触发中断)
> 根据文档描述,触发方式是可以配置<sup>[Learn the architecture - Generic Interrupt Controller v3 and v4#5. Configuring the Arm GIC](././../../006.REFS/learn_the_architecture_-_generic_interrupt_controller_v3_and_v4__overview_198123_0302_03_en.pdf) & [Arm CoreLink GIC-700 Generic Interrupt Controller Technical Reference Manual](../../007.BOOKs/corelink_gic_700_generic_interrupt_controller_trm_101516_0400_12_en.pdf) </sup>的，方式不同，异常处理方法也不同

| 特性 | 边沿触发中断 | 电平触发中断 |
| :--- | :--- | :--- |
| **触发条件** | **信号的电平变化**（边沿） | **信号维持的有效电平** |
| **行为** | 一次性事件，被锁存 | 持续状态，只要电平有效就持续请求 |
| **中断处理期间** | 外设可以在CPU响应后立即撤销信号 | 外设**必须**保持有效电平，直到CPU清除中断原因 |
| **共享中断** | **不适合**，可能导致中断丢失 | **非常适合**，多个设备可以同时拉低电平 |
| **抗抖动/噪声** | 较差，毛刺可能被误认为是有效边沿 | 较好，短暂的毛刺只要不维持，就不会触发 |

The life cycle of an interrupt depends on whether it is configured to be level-sensitive or edge-triggered:
- For level-sensitive interrupts, a rising edge on the interrupt input causes the interrupt to become pending, and the interrupt is held asserted until the peripheral de-asserts the interrupt signal.<sub>对于电平敏感中断，中断输入信号的上升沿将触发中断进入挂起状态，且该中断信号会持续保持有效，直至外设撤销中断信号。</sub>
- For edge-sensitive interrupts, a rising edge on the interrupt input causes the interrupt to become pending, but the interrupt is not held asserted.<sub>对于边沿触发中断，中断输入信号的上升沿会触发中断进入挂起状态，但该中断信号不会持续保持有效。</sub>


---

## 异常发生后的处理<sub>因为处理器硬件不同，异常处理方式不同，因此这里需要结合具体的CPU来分析: arm64</sub>
当一个异常发生时，CPU内核能感知异常发生，而且会对应生成一个目标异常等级（target exception level）。CPU会自动做如下一些事:
> 参考: [ARM Architecture Reference Manual, ARMv8, for ARMv8-A architecture profile] & [奔跑吧Linux内核（第2版）卷1：基础架构#1.7.3　异常发生后的处理](../../007.BOOKs/Run%20Linux%20Kernel%20(2nd%20Edition)%20Volume%201:%20Infrastructure.epub) & [Learn the architecture - AArch64 Exception Model#5. Handling exceptions](../../006.REFS/learn_the_architecture_-_aarch64_exception_model_102412_0103_02_en.pdf)

- 把PSTATE寄存器的值保存到对应目标异常等级的SPSR_ELx寄存器中。
- 把返回地址保存在对应目标异常等级的ELR中。
- 把PSTATE寄存器里的DAIF域都设置为1，相当于把调试异常、系统错误、IRQ以及FIQ都关闭了。PSTATE寄存器是ARM v8里新增的寄存器。
- 对于同步异常，要分析异常的原因，并把具体原因写入ESR_ELx寄存器。
- 设置SP，指向对应目标异常等级里的栈，自动切换SP到SP_ELx寄存器中。
- 从异常发生现场的异常等级切换到对应目标异常等级，然后跳转到异常向量表里执行。

上述是ARMv8处理器检测到异常发生后自动做的事情。操作系统需要做的事情是从中断向量表开始，根据异常发生的类型，跳转到合适的异常向量表。异常向量表的每个项会保存一个异常处理的跳转函数，然后跳转到恰当的异常处理函数并处理异常。

当操作系统的异常处理完成后，执行一条ret指令即可从异常返回。这条指令会自动完成如下工作。
- 从ELR_ELx寄存器中恢复PC指针。
- 从SPSR_ELx寄存器恢复处理器的状态。

当中断发生时，CPU会把PSTATE寄存器的值保存到对应目标异常等级的SPSR_ELx寄存器中，并且把PSTATE寄存器里的DAIF域都设置为1，这相当于把本地CPU的中断关闭了。

当中断处理完成后，操作系统调用eret指令返回中断现场，那么会把SPSR_ELx寄存器恢复到PSTATE寄存器中，这就相当于把中断打开了

---

## 缩写
### SPI PPI SGI LPI <sup>From: [Learn the architecture - Generic Interrupt Controller v3 and v4#4. Arm GIC fundamentals](././../../006.REFS/learn_the_architecture_-_generic_interrupt_controller_v3_and_v4__overview_198123_0302_03_en.pdf) & [Arm CoreLink GIC-700 Generic Interrupt Controller Technical Reference Manual](../../007.BOOKs/corelink_gic_700_generic_interrupt_controller_trm_101516_0400_12_en.pdf) </sup>
The GIC can deal with four different types of interrupt sources:
- Shared Peripheral Interrupt (SPI). Peripheral interrupts that can be delivered to any connected core.
-  Private Peripheral Interrupt (PPI). Peripheral interrupts that are private to one core. An example of a PPI is an interrupt from the Generic Timer.
-  Software Generated Interrupt (SGI). SGIs are typically used for inter-processor communication and are generated by a write to an SGI register in the GIC.
-  Locality-specific Peripheral Interrupt (LPI). LPIs were first introduced in GICv3 and have a very different programing model to the other three types of interrupt. The configuration of LPIs is covered in the Arm CoreLink Generic Interrupt Controller v3 and v4: Locality-specific Peripheral Interrupts guide.



## 参考资料
- [https://developer.arm.com/documentation/198123/0302?lang=en](https://developer.arm.com/documentation/198123/0302?lang=en)
  + [Learn the architecture - Generic Interrupt Controller v3 and v4](././../../006.REFS/learn_the_architecture_-_generic_interrupt_controller_v3_and_v4__overview_198123_0302_03_en.pdf)

- [Arm® CoreLink™ GIC-700 Generic Interrupt Controller](./../../007.BOOKs/corelink_gic_700_generic_interrupt_controller_trm_101516_0400_12_en.pdf)
  + [https://developer.arm.com/documentation/101516/0400/About-the-GIC-700/Component-overview?lang=en](https://developer.arm.com/documentation/101516/0400/About-the-GIC-700/Component-overview?lang=en)
  + The GIC-700 implements version 3, 3.1, and 4.1 of the Arm® Generic Interrupt Controller Architecture Specification, GIC architecture version 3 and version 4. To use GIC-700 with a core, the core must:(GIC-700 实现了 Arm® 通用中断控制器架构规范的第 3、3.1 和 4.1 版本、GIC 架构第 3 版和第 4 版。要使用 GIC-700 带核心，核心必须：)

