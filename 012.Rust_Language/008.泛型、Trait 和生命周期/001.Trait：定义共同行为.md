# Trait：定义共同行为
trait 定义了某个特定类型拥有可能与其他类型共享的功能。可以通过 trait 以一种抽象的方式定义共同行为。可以使用 trait bounds 指定泛型是任何拥有特定行为的类型。

trait 类似于其他语言中的常被称为 接口（interfaces）的功能，虽然有一些不同。



## 定义Trait
一个类型的行为由其可供调用的方法构成。如果可以对不同类型调用相同的方法的话，这些类型就可以共享相同的行为了。trait 定义是一种将方法签名组合起来的方法，目的是定义一个实现某些目的所必需的行为的集合。


### 方法签名
```rust
pub trait Summary {
    // 这个大括号内部定义了 trait 的方法签名
    // 在方法签名后跟分号，而不是在大括号中提供其实现。接着每一个实现这个 trait 的类型都需要提供其自定义行为的方法体，编译器也会确保任何实现 Summary trait 的类型都拥有与这个签名的定义完全一致的 summarize 方法。
    // trait 体中可以有多个方法：一行一个方法签名且都以分号结尾。

    fn summarize(&self) -> String;

    // trait 体中也可以提供默认实现 
    fn summarize_v2(&self) -> String {
        String::from("(Read more...)")
    }
}
```

### 为类型实现 trait
```rust
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct SocialPost {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub repost: bool,
}

impl Summary for SocialPost {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}
```

### trait 作为参数
```rust
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
```

### Trait Bound 语法 <sup>类似于泛型类型限定： Trait Bound（Trait 约束）本质上就是一种针对类型的“功能清单”限定</sup>
```rust
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
// ======> 等价于 

pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
```

适用于 item1 和 item2 允许是不同类型的情况（只要它们都实现了 Summary）。不过如果你希望强制它们都是相同类型呢？但如果我们希望强制两个参数必须具有相同类型，则必须使用 trait bound，如下所示：
```rust
pub fn notify<T: Summary>(item1: &T, item2: &T) {}
```

##### 通过 + 指定多个 trait bound
可以指定多个 trait bound。假设我们希望 notify 在 item 上既能使用格式化显示，又能使用 summarize 方法：在 notify 的定义中，指定 item 必须同时实现 Display 和 Summary 两个 trait:

```rust
pub fn notify(item: &(impl Summary + Display)) {}

pub fn notify<T: Summary + Display>(item: &T) {}
```

##### 通过 where 简化 trait bound
使用过多的 trait bound 也有缺点: 每个泛型有其自己的 trait bound，所以有多个泛型参数的函数在名称和参数列表之间会有很长的 trait bound 信息，这使得函数签名难以阅读。为此，Rust 有另一个在函数签名之后的 where 从句中指定 trait bound 的语法:
```rust
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {}

// 等价于 ----->

fn some_function<T, U>(t: &T, u: &U) -> i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
}
```

## 返回实现了 trait 的类型
也可以在返回值中使用 impl Trait 语法，来返回实现了某个 trait 的类型：
```rust
fn returns_summarizable() -> impl Summary {
    SocialPost {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        repost: false,
    }
}
```

### 静态分发（Static Dispatch）和动态分发（Dynamic Dispatch）
以下这段代码无法编译，因为返回值的类型不一致，无法确定返回值的具体类型。 那怎么处理?
```rust
fn returns_summarizable(switch: bool) -> impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                "Penguins win the Stanley Cup Championship!",
            ),
            location: String::from("Pittsburgh, PA, USA"),
            author: String::from("Iceburgh"),
            content: String::from(
                "The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.",
            ),
        }
    } else { // 这段代码无法编译，因为返回值的类型不一致，无法确定返回值的具体类型： returns_summarizable
        SocialPost {
            username: String::from("horse_ebooks"),
            content: String::from(
                "of course, as you probably already know, people",
            ),
            reply: false,
            repost: false,
        }
    }
}


// ==== 修改后： 使用Box<dyn Summary> 
//  ---> dyn 兼容性（dyn compatibility），用于规定可以和不可以在哪些地方使用动态分发
//  ---> dyn: 核心功能是开启 Rust 的 动态分发（Dynamic Dispatch）
fn returns_summarizable(switch: bool) -> Box<dyn Summary> {
    if switch {
        Box::new(NewsArticle {
            headline: String::from("Penguins win the Stanley Cup Championship!"),
            location: String::from("Pittsburgh, PA, USA"),
            author: String::from("Iceburgh"),
            content: String::from(
                "The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.",
            ),
        })
    } else {
        Box::new(SocialPost {
            username: String::from("horse_ebooks"),
            content: String::from("of course, as you probably already know, people"),
            reply: false,
            repost: false,
        })
    }
}

为什么这里一定要用 Box<dyn Summary>？ 这就涉及到 Rust 中的静态分发（Static Dispatch）和动态分发（Dynamic Dispatch）了。

1. **泛型（静态分发）的局限**：
如果你尝试写 `fn returns_summarizable<T: Summary>(...) -> T`，编译器会报错。因为**泛型是在编译期确定一个具体类型**。在这个函数里，你可能返回 `NewsArticle`，也可能返回 `SocialPost`，编译器无法在编译阶段确定 `T` 到底是谁。
2. **对象安全（动态分发）**：
使用 `Box<dyn Summary>` 意味着你告诉编译器：“我不在乎具体类型，我只在乎它在堆上，并且它实现了 `Summary` 接口。”
* **静态分发 (Generic)**：编译时生成多个副本（单态化）。
* **动态分发 (Trait Object)**：运行时通过 **虚表 (vtable)** 查找方法。
```

